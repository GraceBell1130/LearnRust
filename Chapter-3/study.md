rust는 기본적으로 변수는 불변성이다.

가변형으로 만들고 싶을 때는 변수명의 접두어로 `mut`을 추가하여 변수를 선언하면 된다.

상수와 rust 변수의 차이점
- 상수는 기본 설정이 불변성인 것이 아니라 불변성 그 자체
- 상수를 사용하기 위해서 `let` 키워드 대신 `const` 키워드를 사용해야 하고, 값의 유형을 선언해야 함
- 상수는 전체 영역을 포함하여 어떤 영역에서도 선언될 수 있음
- 상수는 오직 상수 표현식만 설정될 수 있지, 함수 호출의 결과값이나 그 외에 실행 시간에 결정되는 값이 설정될 수 없음

Rust의 상수 명명 규칙은 모든 단어를 대문자로 사용하는 것이다.

이전에 선언한 변수와 같은 이름의 새 변수를 선언하고 이전에 선언한 변수를 새 변수에 할당하는 것을 'shadowed'됐다고 함
```
ex)
let x = 5;
let x = x + 1; // shadwed 되었음
```
위와 같은 방식은 `mut`으로 선언하는 것과는 차이
- `let` 키워드를 사용하지 않고 변수에 새로 값을 대입하려고 하면 컴파일시에 에러를 얻게되기 때문
- `let` 키워드를 다시 사용하여 효과적으로 새 변수를 선언하고, 값의 유형을 변경할 수 있으면서도 동일 이름을 사용할 수 있음

---

Rust에서 사용되는 모든 값들은 *어떤 타입*을 갖기에 어떤 형태의 데이터인지 명시하여 Rust에게 알려줘서 이를 통해 데이터를 어떻게 다룰지 알 수 있도록 해야한다.

Rust는 *타입이 고정된* 언어다.
- 모든 변수의 타입이 컴파일 시에 반드시 정해져 있어야 한다.

스칼라 : 하나의 값으로 표현되는 타입이며 Rust는 네가지 타입을 보유하고 있다.
- 정수형 : 소수점이 없는 숫자
    - i(8|16|32|64|size) : 부호있는 타입의 접두어(부호 - 2의 보수 형태를 사용하여 저장)
    - u(8|16|32|64|size) : 부호없는 타입의 접두어(미부호)
    - (i|u)size 타입은 프로그램이 동작하는 컴퓨터 환경에 따라 결정이 됨
        - 64-bit 아키텍처이면 64bit, 32-bit 아키텍처이면 32bit
        - 일부 콜렉션 타입의 색인에 사용이 됨
    - 정수형 리터럴을 사용할 수 있음
        - Decimal : 98_000 == 98000
        - Hex : 0xff
        - Octal : 0o77
        - Binary : 0b1111_0000 == 0b11110000
        - Byte : b'A'
    - 확실하게 정수 타입이 정해지지 않으면 i32가 좋은 선택이다. 그 이유는 가장 빠르기 때문
- 부동소수점 숫자
    - f(32|64) : 부동소수점 타입
        - 32 : 32bit의 크기
        - 64 : 64bit의 크기
- boolean
    - (true|false) : boolean 타입
- 문자
    - char : 작은따옴표를 사용하여 선언
        - Unicode Scalar(U+0000 ~ U+D7FF, U+E000 ~ U+10FFFF)를 표현하는 값 
    - string : 큰따옴표를 사용하여 선언 

복합타입 : 다른 타입의 다양한 값들을 하나의 타입으로 묶을 수 있음
- 튜플 : 포함되는 각 값의 타입이 동일할 필요없이 서로 달라도 됨
```
ex) 
let tup: (i32, f64, u8) = (500, 6.4, 1);
let (x, y, z) = tup; 
// x == 500
// y == 6.4
// z == 1
let five_fundred = tup.0;
let six_point_four = tup.1;
let one = tup.2;
```
- 배열 : 모든 요소는 모두 같은 타입이어여야 함
    - Rust의 배열은 고정된 길이를 갖는다.
    - 데이터를 heap보다 stack에 할당할 때 사용
    - 고정된 숫자의 요소를 갖는다고 확신할 때 사용
```
ex)
let a = [1, 2, 3, 4, 5];
let first = a[0]; // 1
let second = a[1]; // 2
let outbound = a[10] // 컴파일 시에는 에러가 발생하지 않지만 프로그램 실행 중에 에러가 발생
```

패닉(panic) : 프로그램이 오류와 함께 종료 될 때 Rust가 사용하는 용어

---

Rust는 snake 형태로 변수나 함수 이름을 작성
- ex) sample_function, sample_variable

`fn` : 새로운 함수의 선언을 해주는 키워드
- 중괄호는 컴파일러에게 함수의 시작과 종료 지점을 알려주게 됨
- Rust는 전방선언을 할 필요없이 어디서든지 함수 정의가 가능
- 함수의 선언부에서 *반드시* 각 매개변수의 타입을 정의해야 함
- 여러 개의 매개변수를 사용하고 싶으면 쉼표로 구분해서 사용
- 함수의 값을 반환하기 위해서는 `->`를 뒤에 선언해야 한다.
```
fn sample_function(x: i32, y: i8) -> i64 {
    println!("The value of x is {}", x);
    println!("The value of y is {}", y);
    return x + y;
}
```

구문 : 어떤 명령들의 나열로 값을 반환하지 않는 어떤 동작을 수행  
표현식 : 결과 값을 산출
```
let x = (let y = 6); // error
let x = 5;  // 해당 코드는 구문
            // 5는 5란 값을 산출하는 표현식
let y = {   // y는 4
    let x = 3;
    x + 1   // 표현식은 종결을 나타내는 세미콜론을 사용하지 않음
            // 세미콜론을 추가하면 구문으로 변경이 되고 반환 값이 아니게 됨
}
```

```
fn five() -> i32 { // 대부분의 함수들은 암묵적으로 마지막 표현식을 반환
    5               // 해당 값은 표현식이므로 세미콜론이 없음
                    // 만약 5;로 작성하면 five() 구문은 값을 산출하기 않기에 비어있는 튜플로 표현이 됨
}

fn main() {
    let x = five() // x는 5
}
```

--- 

`if` : 조건에 따라 분기할 수 있게 해줌
- `if`란 키워드로 시작하며 뒤이어 조건이 옴
- 조건은 반드시 `bool` 이어야 함
- `else`를 이용하여 거짓일 경우 실행되는 구문을 작성할 수 있음
- `else if`를 이용하여 추가적인 조건 분기를 작성할 수 있음
```
ex)
let number = 3;

if number { // expected type 'bool' 에러 발생
    ...
}

let condition = true;

let variable = if condition { // variable은 5의 값을 가짐
    5       
} else {
    6
};                            // 표현식의 타입은 모두 같은 타입이어야 함
```

`loop` : Rust에게 그만두라고 명시하여 알려주기 전까지 코드 블럭을 반복 수행하는 키워드
- `break` : `loop`를 빠져나갈 수 있게하는 키워드
- `while`과 다르게 조건이 없으며 `break` 키워드가 없으면 ctrl-C를 눌렀을 때 종료가 됨

`while` : 조건이 참인 동안 코드 블럭을 반복 수행
```
let a = [10, 20, 30, 40];
let mut index = 0;

while index < 5 {
    ...
    index = index + 1;
}

```
`for` : 콜렉션의 각 요소를 순회하여 코드 블럭을 반복 수행
```
ex)
let a = [10, 20, 30, 40];

for element in a.iter() {
    ...
}
```


